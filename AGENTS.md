# Repository Guidelines

## Project Structure & Module Organization
- Entry HTML: index.html.
- App source: src/ (React). Key folders: components/ for UI, hooks/ for reusable logic, context/ for shared state, data/ for static data, services/ for API calls, utils/ for helpers, styles/ and *.css for global styling, assets/ for images and static assets.
- Built assets: dist/ (generated by Vite, do not edit), public/ for static files served as is.

## Build, Test, and Development Commands
Run commands from the repository root:
- npm install – install dependencies.
- npm run dev – start local dev server.
- npm run build – create production build in dist/.
- npm run preview – preview the production build.
- npm run lint – run ESLint on the codebase.

## Coding Style & Naming Conventions
- Use React function components with hooks. Place shared UI in src/components/.
- File names: PascalCase.jsx for components, camelCase.js for utilities and hooks (hooks start with use), kebab-case.css for styles if added.
- Prefer 2 space indentation, double quotes in JSX, and consistent semicolon usage.
- ESLint is configured in eslint.config.js. Fix issues via npm run lint and editor integration.

## Testing Guidelines
- A test runner is not yet configured. When introducing tests, colocate them near source files using names like Component.test.jsx and keep them fast and deterministic.
- Document any new test setup in this file and in README.md.

## Commit and Pull Request Guidelines
- Write concise, imperative commit messages, for example Add exam prediction chart or Fix DeepSeek API error handling.
- Group related changes into a single commit or pull request.
- For UI changes, include before or after screenshots in the pull request description when possible.
- Reference related issues with Closes #ID or Related to #ID in the description.

## Security and Configuration
- Store secrets such as VITE_DEEPSEEK_API_KEY in a local .env file and never commit them.
- The browser client talks directly to DeepSeek in development. For production deployments, prefer routing API traffic through a backend proxy and applying additional rate limiting and logging.
